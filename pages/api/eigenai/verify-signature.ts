import type { NextApiRequest, NextApiResponse } from 'next';
import { ethers } from 'ethers';

/**
 * EigenAI Signature Verification API
 * 
 * Verifies cryptographic signatures from EigenAI API responses
 * 
 * POST /api/eigenai/verify-signature
 * Body: {
 *   tweetText: string,          // Original tweet/message text
 *   llm_signature: string,      // Signature from EigenAI
 *   llm_raw_output: string,     // Full raw output with <|channel|> tags
 *   llm_model_used: string,     // Model ID (e.g., "gpt-oss-120b-f16")
 *   llm_chain_id: number,       // Chain ID (usually 1)
 *   operator_address?: string   // Optional: EigenAI operator address (defaults to official)
 *   marketContext: string,      // Market data context generated by llm-classifier using lunar crush data
 * }
 * 
 * Response: {
 *   success: boolean,
 *   isValid: boolean,
 *   recoveredAddress: string,
 *   expectedAddress: string,
 *   message?: string
 * }
 */

// Default EigenAI operator address
const DEFAULT_EIGENAI_OPERATOR_ADDRESS = "0x7053bfb0433a16a2405de785d547b1b32cee0cf3";

// System message (must match llm-classifier)
const SYSTEM_MESSAGE = "Output ONLY valid JSON. No text, no explanations, no <think> tags. Start response with { and end with }. ONLY JSON.";

// Build prompt (must match llm-classifier buildPromptWithMarketData)
function buildPromptWithMarketData(
  tweetText: string,
  marketContext: string | undefined
): string {
  const ctx = marketContext && marketContext.trim().length > 0
    ? marketContext
    : "NO MARKET DATA AVAILABLE";

  return `Tweet: "${tweetText}"
Market: ${ctx}

Score tweet 0.0-1.0 for trade confidence. Lower if: negative momentum, high vol, vague tweet, poor altrank, low liquidity.

JSON only:
{"isSignalCandidate":true/false,"extractedTokens":["TOKEN"],"sentiment":"bullish"/"bearish"/"neutral","confidence":0.XX,"reasoning":"Brief analysis"}`;
}

// Extract prompt (concatenate system + user messages)
function extractPrompt(tweetText: string, marketContext?: string): string {
  const userMessage = buildPromptWithMarketData(tweetText, marketContext);
  return SYSTEM_MESSAGE + userMessage;
}

// Construct message for verification
function constructMessage(
  chainId: string | number,
  modelId: string,
  prompt: string,
  output: string
): string {
  const chainIdStr = typeof chainId === 'number' ? String(chainId) : chainId;
  return chainIdStr + modelId + prompt + output;
}

// Verify signature using ethers.js
function verifySignature(
  message: string,
  signature: string,
  expectedAddress: string
): { isValid: boolean; recoveredAddress: string } {
  try {
    const sigHex = signature.startsWith('0x') ? signature : '0x' + signature;
    const recoveredAddress = ethers.utils.verifyMessage(message, sigHex);
    const isValid = recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    
    return {
      isValid,
      recoveredAddress,
    };
  } catch (error) {
    console.error('[EigenAI] Signature verification error:', error);
    throw error;
  }
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false,
      error: 'Method not allowed. Use POST.' 
    });
  }

  try {
    // Extract request body
    const {
      tweetText,
      llm_signature,
      llm_raw_output,
      llm_model_used,
      llm_chain_id,
      marketContext,
      llm_full_prompt,
      operator_address,
    } = req.body;

    // Validate required fields
    if (!tweetText) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: tweetText'
      });
    }

    if (!llm_signature) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: llm_signature'
      });
    }

    if (!llm_raw_output) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: llm_raw_output'
      });
    }

    if (!llm_model_used) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: llm_model_used'
      });
    }

    if (llm_chain_id === undefined || llm_chain_id === null) {
      return res.status(400).json({
        success: false,
        error: 'Missing required field: llm_chain_id'
      });
    }
    const promptMarketContext = marketContext || "NO MARKET DATA AVAILABLE";

    // Use provided operator address or default
    const expectedAddress = operator_address || DEFAULT_EIGENAI_OPERATOR_ADDRESS;

    console.log('[EigenAI] Verifying signature...');
    console.log(`  Chain ID: ${llm_chain_id}`);
    console.log(`  Model: ${llm_model_used}`);
    console.log(`  Expected Address: ${expectedAddress}`);

    // Step 1: Extract prompt
    // Use stored fullPrompt if available (exact prompt sent to EigenAI)
    // Otherwise reconstruct from tweetText + marketContext (backward compatibility)
    let prompt = llm_full_prompt || extractPrompt(tweetText, promptMarketContext);
    
    console.log('\n=== PROMPT ANALYSIS ===');
    if (llm_full_prompt) {
      console.log('  ✓ Using stored full prompt from DB');
      console.log(`  Full prompt length: ${llm_full_prompt.length}`);
      console.log(`  Full prompt first 200 chars: "${llm_full_prompt.substring(0, 200)}"`);
      console.log(`  Full prompt last 200 chars: "${llm_full_prompt.substring(llm_full_prompt.length - 200)}"`);
    } else {
      console.log('  ✗ Reconstructing prompt from tweetText + marketContext');
      const reconstructed = extractPrompt(tweetText, promptMarketContext);
      console.log(`  Reconstructed prompt length: ${reconstructed.length}`);
      console.log(`  Reconstructed first 200: "${reconstructed.substring(0, 200)}"`);
    }

    console.log('\n=== RAW OUTPUT ANALYSIS ===');
    console.log(`  Raw output length: ${llm_raw_output.length} characters`);
    console.log(`  Raw output first 200 chars: "${llm_raw_output.substring(0, 200)}"`);
    console.log(`  Raw output last 100 chars: "${llm_raw_output.substring(llm_raw_output.length - 100)}"`);

    // Step 2: Try verification with the prompt
    let message = constructMessage(
      llm_chain_id,
      llm_model_used,
      prompt,
      llm_raw_output
    );

    console.log('\n=== MESSAGE CONSTRUCTION ===');
    console.log(`  Chain ID: "${llm_chain_id}" (${String(llm_chain_id).length} chars)`);
    console.log(`  Model ID: "${llm_model_used}" (${llm_model_used.length} chars)`);
    console.log(`  Prompt length: ${prompt.length} characters`);
    console.log(`  Output length: ${llm_raw_output.length} characters`);
    console.log(`  Total message length: ${message.length} characters`);
    console.log(`  Expected: ${String(llm_chain_id).length} + ${llm_model_used.length} + ${prompt.length} + ${llm_raw_output.length} = ${String(llm_chain_id).length + llm_model_used.length + prompt.length + llm_raw_output.length}`);
    console.log(`  Message first 300 chars: "${message.substring(0, 300)}"`);
    console.log(`  Message last 200 chars: "${message.substring(message.length - 200)}"`);
    
    console.log('\n=== SIGNATURE VERIFICATION ===');

    // Try verification
    let verificationResult = verifySignature(
      message,
      llm_signature,
      expectedAddress
    );

    console.log(`  Attempt 1 (full prompt): Recovered=${verificationResult.recoveredAddress}, Valid=${verificationResult.isValid}`);

    // If verification fails and we used fullPrompt (which might include system message),
    // try again with ONLY the user message (skip system message)
    if (!verificationResult.isValid && llm_full_prompt && llm_full_prompt.startsWith('You are a crypto trading signal analyst')) {
      console.log('\n=== RETRY WITHOUT SYSTEM MESSAGE ===');
      console.log('  First attempt failed, trying without system message...');
      
      // Extract only the user message part (after the system message)
      const SYSTEM_MSG = "You are a crypto trading signal analyst. Output ONLY valid JSON. No explanations, no reasoning text outside JSON, ONLY the JSON object. Start with { and end with }.";
      if (llm_full_prompt.startsWith(SYSTEM_MSG)) {
        const userPromptOnly = llm_full_prompt.substring(SYSTEM_MSG.length);
        console.log(`  User prompt only length: ${userPromptOnly.length}`);
        console.log(`  User prompt first 200: "${userPromptOnly.substring(0, 200)}"`);
        
        message = constructMessage(
          llm_chain_id,
          llm_model_used,
          userPromptOnly,
          llm_raw_output
        );
        
        console.log(`  New message length: ${message.length}`);
        
        verificationResult = verifySignature(
          message,
          llm_signature,
          expectedAddress
        );
        
        console.log(`  Attempt 2 (user only): Recovered=${verificationResult.recoveredAddress}, Valid=${verificationResult.isValid}`);
        
        if (verificationResult.isValid) {
          console.log('  ✓ SUCCESS: Verification passed with user prompt only (no system message)');
        } else {
          console.log('  ✗ FAILED: Still invalid even without system message');
        }
      }
    }

    // Final result logging
    console.log('\n=== FINAL RESULT ===');
    console.log(`  Recovered Address: ${verificationResult.recoveredAddress}`);
    console.log(`  Expected Address: ${expectedAddress}`);
    console.log(`  Is Valid: ${verificationResult.isValid}`);

    // Return result
    return res.status(200).json({
      success: true,
      isValid: verificationResult.isValid,
      recoveredAddress: verificationResult.recoveredAddress,
      expectedAddress: expectedAddress,
      message: verificationResult.isValid 
        ? 'Signature verified successfully' 
        : 'Signature verification failed - address mismatch',
      details: {
        chainId: llm_chain_id,
        model: llm_model_used,
        messageLength: message.length,
      }
    });

  } catch (error) {
    console.error('[EigenAI] Verification error:', error);
    
    return res.status(500).json({
      success: false,
      error: 'Signature verification failed',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

